---------------------------------------------------------------------------------------------------------------------------
Render Entity Code where I began to add the aspect ratio handling.  Bad idea, belongs somewhere else:

    def render_entity(self, image, x, y, entity):
        
        w, h = image.get_size()
        
        #Are we in view?
        if self.world_viewable_rect.colliderect(pygame.Rect(x-w/2, y-h/2, w, h)):
            
            #Code for keeping the aspect ratio on the viewport.
            #Making new copies of these because we might change them based on aspect ratio in the test further down.
            viewport_usable_width = self.zoom_area_width
            viewport_usable_height = self.zoom_area_height
            aspect_ratio_offset_width = 0
            aspect_ratio_offset_height = 0
            
            #Determine if adjustments based on aspect ratio are required.
            if (float(self.zoom_area_width) / float(self.zoom_area_height) - float(self.width) / float(self.height)) > .2:
                #Determine if it's width or height that's out of wack and then take proper action.
                viewport_aspect_ratio = float(self.width / self.height)
                zoom_area_aspect_ratio = float(self.zoom_area_width / self.zoom_area_height)
            
                #Should we go full width or height with the minimap based on the aspect ratio?  
                if (zoom_area_aspect_ratio >= 1) and (zoom_area_aspect_ratio >= viewport_aspect_ratio):
                    #Use width of the viewport.
                    viewport_usable_width = self.width
                    viewport_usable_height = self.zoom_area_height / float((self.zoom_area_width) / float(self.width))
                    #Calculate the offset of the viewport based on the aspect ratio.
                    aspect_ratio_offset_width = 0
                    aspect_ratio_offset_height = (self.height - viewport_usable_height) / 2
                else:
                    #Use height of the minimap.
                    viewport_usable_width = self.zoom_area_width / float((self.zoom_area_height) / float(self.height))
                    viewport_usable_height = self.height
                    #Calculate the offset of the viewport based on the aspect ratio.
                    aspect_ratio_offset_width = (self.width - viewport_usable_width) / 2
                    aspect_ratio_offset_height = 0
       
            
            print "viewport usable width, height: ", viewport_usable_width, viewport_usable_height
            #Determine scale factor.  Used in calculating position in the viewport.
            scale_factor_width = self.zoom_area_width/viewport_usable_width
            scale_factor_height = self.zoom_area_height/viewport_usable_height
            
            print "scale factors: ", scale_factor_width, scale_factor_height
            #Convert object's coordinates to the viewport we're drawing on.
            #Convert world coordinates to world viewable coordinates, then to viewport coordinates.
            x = (x - (self.world_viewable_center_x - self.zoom_area_width/2)) / scale_factor_width  + aspect_ratio_offset_width
            y = (y - (self.world_viewable_center_y - self.zoom_area_height/2)) / scale_factor_height + aspect_ratio_offset_height
            
            print x, y
            #Render as scaled image or filled square? 
            if self.current_zoom_level > 5:
                #Render as square
                self.surface.fill(entity.color, (x-5, y-5, 10, 10))           
            else:
                #Render as scaled object
                if self.current_zoom_level != 2:  #Meaning scaling is required:
                    #scale the image
                    image = pygame.transform.scale(image, (int(w/scale_factor_width), int(h/scale_factor_height)))
                    w, h = image.get_size()
                self.surface.blit(image, (x-w/2, y-h/2))


----------------------------------------------------------------------------------------------------------------------------
Orginal world_viewport code prior to new zooming method:

class World_Viewport2(viewport.Viewport):
    def __init__(self, world_width, world_height, viewable_width, viewable_height):
        viewport.Viewport.__init__(self, 0, 0, viewable_width, viewable_height, 1, 0, True)

        self.world_height = world_height
        self.world_width = world_width

        #default zoom level
        self.zoom_level = 2

        #Scroll speeds that will be used based on zoom level
        self.scroll_speeds = (5, 10, 20, 40, 60, 100)
        #default scroll speed
        self.scroll_speed = 10
        
        self.setup_viewable_area()
        
    @viewport.Viewport.width.setter
    def width(self, value):
        self.width = value
        self.setup_viewable_area()
        
    @viewport.Viewport.height.setter
    def height(self, value):
        self._height = value
        self.setup_viewable_area()
               
    def prepare_new_frame(self):
        self.zoom_frame_buffer.blit(self.background, (0, 0))

    #We check to see if it's in the field of vision and render if so.
    def render_entity(self, image, x, y):
        
        w, h = image.get_size()
        
        if self.viewport_rect.colliderect(pygame.Rect(x-w/2, y-h/2, w, h)):
            #We're in view.
            #Convert object's coordinates to the surface we're drawing on.
            x = x - (self.viewport_center_x - self.zoom_area_width/2)
            y = y - (self.viewport_center_y - self.zoom_area_height/2)
            self.zoom_frame_buffer.blit(image, (x-w/2, y-h/2))
    
    def setup_viewable_area(self):

        self.zoom_area_width = self.width
        self.zoom_area_height = self.height
        
        #Zoom levels as tuples.
        self.zoom_level_1 = (self.width/2, self.height/2)
        self.zoom_level_2 = (self.width, self.height)
        self.zoom_level_3 = (self.width+self.width/2, self.height+self.height/2)
        self.zoom_level_4 = (self.width*2, self.height*2)
        self.zoom_level_5 = (self.width*3, self.height*3)
        self.zoom_level_6 = (self.world_width, self.world_height)
        #List of tuples representing the zoom levels, not used and probably should be removed.
        self.zoom_levels = (self.zoom_level_1, self.zoom_level_2, self.zoom_level_3, self.zoom_level_4, self.zoom_level_5, self.zoom_level_6)

        self.viewport_center_x = self.world_width / 2
        self.viewport_center_min_x = self.zoom_area_width/2
        self.viewport_center_max_x = self.world_width - self.zoom_area_width/2
        self.viewport_center_y = self.world_height / 2
        self.viewport_center_min_y = self.zoom_area_height/2
        self.viewport_center_max_y = self.world_height - self.zoom_area_height/2

        #Defining the rectangle of the viewport
        self.viewport_x_rect = self.viewport_center_x - self.zoom_area_width/2
        self.viewport_y_rect = self.viewport_center_y - self.zoom_area_height/2
        self.viewport_rect = pygame.Rect(self.viewport_x_rect, self.viewport_y_rect, self.zoom_area_width, self.zoom_area_height)

        #The zoom_frame_buffer is the surface where everything is rendered (blited) to.  It will then be scaled to fit the viewport.
        self.zoom_frame_buffer = pygame.surface.Surface((self.zoom_area_width, self.zoom_area_height)).convert()
        
        #Setting the surface to the correct size
        self.surface = pygame.surface.Surface((self.width, self.height)).convert()
        
        #Let's prepare the backgound image.  It will just be white.
        self.background = pygame.surface.Surface((self.zoom_area_width, self.zoom_area_height)).convert()
        self.background.fill((255, 255, 255))
        
    def in_field_of_vision(self):
        pass

    #A function for updating the viewport center point.  Other variables are updated also to keep everything in sync.  Called only from the x, y adjustment functions found further below.
    #On the other hand, one could call this directly if one was implementing a feature to follow a moving unit.
    def update_viewport_center(self, x, y):
       
        self.viewport_center_x = x
        self.viewport_center_y = y
        self.viewport_x_rect = x - self.zoom_area_width/2
        self.viewport_y_rect = y - self.zoom_area_height/2
        self.viewport_rect = pygame.Rect(self.viewport_x_rect, self.viewport_y_rect, self.zoom_area_width, self.zoom_area_height)
    
    def add_to_viewport_x(self, what_to_add):
    
        #Go ahead and make the adjustment if we're not going over the max center point.
        if self.viewport_center_x + what_to_add < self.viewport_center_max_x:
            self.update_viewport_center(self.viewport_center_x + what_to_add, self.viewport_center_y) 
        else:
            #We might be scrolling with odd numbers, so let's go to the outmost edge.
            self.update_viewport_center(self.viewport_center_max_x, self.viewport_center_y)
        
    def subtract_from_viewport_x(self, what_to_subtract):
    
        #Go ahead and make the adjustment if we're not going under the min center point.
        if self.viewport_center_x - what_to_subtract > self.viewport_center_min_x:
            self.update_viewport_center(self.viewport_center_x - what_to_subtract, self.viewport_center_y)
        else:
            #We might be scrolling with odd numbers, so let's go to the outmost edge.
            self.update_viewport_center(self.viewport_center_min_x, self.viewport_center_y)
             
    def add_to_viewport_y(self, what_to_add):
    
        #Go ahead and make the adjustment if we're not going over the max center point.
        if self.viewport_center_y + what_to_add < self.viewport_center_max_y:
            self.update_viewport_center(self.viewport_center_x, self.viewport_center_y + what_to_add)
        else:
            #We might be scrolling with odd numbers, so let's go to the outmost edge.
            self.update_viewport_center(self.viewport_center_x, self.viewport_center_max_y) 
        
    def subtract_from_viewport_y(self, what_to_subtract):
    
        #Go ahead and make the adjustment if we're not going under the min center point.
        if self.viewport_center_y - what_to_subtract > self.viewport_center_min_y:
            self.update_viewport_center(self.viewport_center_x, self.viewport_center_y - what_to_subtract)
        else:
            #We might be scrolling with odd numbers, so let's go to the outmost edge.
            self.update_viewport_center(self.viewport_center_x, self.viewport_center_min_y)

    #When the zoom level is changed, several variables must be changed with it.
    def update_zoom_level(self, level):
    
        x, y = level
    
        self.zoom_area_width = x
        self.zoom_area_height = y
    
        self.viewport_center_min_x = self.zoom_area_width/2
        self.viewport_center_max_x = self.world_width - self.zoom_area_width/2

        self.viewport_center_min_y = self.zoom_area_height/2
        self.viewport_center_max_y = self.world_height - self.zoom_area_height/2
    
        #Test to see if viewport center is out of range after the the zoom, if so, fix'um up.  This can happen if you're at the edge of the screen and then zoom out - the center will be close to the edge.
        if self.viewport_center_x > self.viewport_center_max_x:
            self.viewport_center_x = self.viewport_center_max_x
        if self.viewport_center_x < self.viewport_center_min_x:
            self.viewport_center_x = self.viewport_center_min_x
        if self.viewport_center_y > self.viewport_center_max_y:
            self.viewport_center_y = self.viewport_center_max_y
        if self.viewport_center_y < self.viewport_center_min_y:
            self.viewport_center_y = self.viewport_center_min_y
           
        #Recalculate the other variables by calling update_viewport_center without changing the values of the center.
        self.update_viewport_center(self.viewport_center_x, self.viewport_center_y)
    
        #Redefine the size of the surface for the zoom_frame_buffer
        self.zoom_frame_buffer = pygame.surface.Surface(level).convert()
    
        #Redefine the size of the surface for the background
        self.background = pygame.surface.Surface(level).convert()
        self.background.fill((255, 255, 255))
        
        #Change the scroll_speed based on the zoom level.
        self.scroll_speed = self.scroll_speeds[self.zoom_level]
    
    
    #This function is called to do the final scaling of the image to fit the viewport/screen size.
    def finalize_image(self):
    
        #Let's take the zoom frame buffer and transform to the resolution of the screen and then copy it to the screen surface.
        pygame.transform.scale(self.zoom_frame_buffer, (self.width, self.height), self.surface)
        #pass

    def change_zoom_level(self, direction):
    
        if direction == "in":
            if self.zoom_level > 0:
                self.zoom_level = self.zoom_level - 1
                self.update_zoom_level(self.zoom_levels[self.zoom_level])
        if direction == "out":
            if self.zoom_level < 5:
                self.zoom_level = self.zoom_level + 1
                self.update_zoom_level(self.zoom_levels[self.zoom_level]) 
 
    @classmethod
    def find_screen_mapped_rect(cls, viewport):
        """  Determines viewports rectangle on screen.  """
        
        #We're interested in current_w and current_h
        screen_attributes = pygame.display.Info()
        #Rect for the physical screen.
        screen_rect = (0, 0, screen_attributes.current_w, screen_attributes.current_h)
        #Rect for the viewport being passed in.
        passed_in_rect = pygame.Surface.get_rect(viewport.surface)





class ControlPanel(object):
    
    def __init__(self, world):
        
        self.font = pygame.font.SysFont("arial", 16);
        screen_width, screen_height = global_data.screen_size
        panel_height = 256
        panel_starting_position = screen_height - panel_height
        size_of_world_stats = 280
        size_of_team_stats = 445
        
        #Draw static elements on the control panel.
        #Horizontal Line
        pygame.draw.line(world.background, (0, 0, 255), (0, panel_starting_position), (screen_width, panel_starting_position), 5)
        #First deliminator
        pygame.draw.line(world.background, (0, 0, 255), (size_of_world_stats, panel_starting_position), (size_of_world_stats, screen_height), 5)
        #second deliminator
        pygame.draw.line(world.background, (0, 0, 255), (740, 512), (740, 768), 5)
        
        font = pygame.font.SysFont("arial", 16);
        label = font.render("World Statistics", True, (0, 0, 0))
        world.background.blit(label, (5, screen_height - panel_height + 7))
        label = font.render("Total Number of Ants: ", True, (0, 0, 0))
        world.background.blit(label, (5, screen_height - panel_height + 32))
        label = font.render("Number of Leaves on Screen: ", True, (0, 0, 0))
        world.background.blit(label, (5, screen_height - panel_height + 57))
        label = font.render("Number of Returned Leaves: ", True, (0, 0, 0))
        world.background.blit(label, (290, screen_height - panel_height + 32))
        label = font.render("Number of Leaves in Base: ", True, (0, 0, 0))
        world.background.blit(label, (290, screen_height - panel_height + 57))       
        label = font.render("Number of Food Units: ", True, (0, 0, 0))
        world.background.blit(label, (290, screen_height - panel_height + 82))
        label = font.render("Team 1      Team 2", True, (0, 0, 0))
        world.background.blit(label, (525, screen_height - panel_height + 7))
        label = font.render("MiniMap", True, (0, 0, 0))
        world.background.blit(label, (850, screen_height - panel_height + 7))
        #Other Stuff
        self.ant_location = (225, screen_height - panel_height + 32)
        self.leaf_location = (225, screen_height - panel_height + 57)
        self.leaf_returned_location = (520, screen_height - panel_height + 32)
        self.leaf_in_base_location = (520, screen_height - panel_height + 57)
        self.food_units_location = (520, screen_height - panel_height + 82)
        
    #Let's render all the interesting things about the world        
    def render(self, surface, world):
  
        label = self.font.render(str(world.count("ant")), True, (0, 0, 0))
        surface.blit(label, self.ant_location)
        label = self.font.render(str(world.count("leaf")), True, (0, 0, 0))
        surface.blit(label, self.leaf_location)   
    
    def render_base_stats(self, surface, world, base, offset):
        label = self.font.render(str(base.leaves_returned), True, (0, 0, 0))
        x, y = self.leaf_returned_location
        surface.blit(label, (x + offset, y))
        label = self.font.render(str(base.leaves), True, (0, 0, 0))
        x, y = self.leaf_in_base_location
        surface.blit(label, (x + offset, y))
        label = self.font.render(str(base.food_units), True, (0, 0, 0))
        x, y = self.food_units_location
        surface.blit(label, (x + offset, y))
        
        
class SethStateExploring(State):
    
    def __init__(self, seth):
        
        State.__init__(self, "exploring")
        self.seth = seth
        
    def random_destination(self):
        
        self.seth.destination = Vector2(randint(0, self.seth.world.width), randint(0, self.seth.world.height))    
    
    def do_actions(self):
        
        if randint(1, 20) == 1:
            self.random_destination()
            
    def check_conditions(self):

        if self.seth.world.sri == True:
            return "panic"                        
        leaf = self.seth.world.get_close_entity("leaf", self.seth.location)        
        if leaf is not None:
            self.seth.leaf_id = leaf.id
            return "seeking"        
        
        return None
    
    def entry_actions(self):
        
        self.seth.speed = 120. + randint(-30, 30)
        self.random_destination()
        
class SethStateSeeking(State):
    
    def __init__(self, seth):
        
        State.__init__(self, "seeking")
        self.seth = seth
        self.leaf_id = None
    
    def check_conditions(self):
 
        if self.seth.world.sri == True:
            return "panic"       
        
        leaf = self.seth.world.get(self.seth.leaf_id)
        if leaf is None:
            return "exploring"
        
        if self.seth.location.get_distance_to(leaf.location) < 5.0:
            self.seth.world.remove_entity(leaf)  #Removing leaf from the world
            self.seth.hungry = 0
            return "eating"
        
        return None
    
    def entry_actions(self):
    
        leaf = self.seth.world.get(self.seth.leaf_id)
        if leaf is not None:                        
            self.seth.destination = leaf.location
            self.seth.speed = 160. + randint(-20, 20)

class SethStateEating(State):
    
    def __init__(self, seth):
        
        State.__init__(self, "eating")
        self.seth = seth
        
        
    def check_conditions(self):

        if self.seth.world.sri == True:
            return "panic"        
        #Have we eaten our fill?        
        if self.seth.hungry < 1000:
            self.seth.hungry += 25
        else:
            return "exploring"            
        return None
        
        
    def entry_actions(self):
        
        self.seth.speed = 0.        
        #random_offset = Vector2(randint(-20, 20), randint(-20, 20))
        #self.ant.destination = Vector2(*self.ant.base_location) # + random_offset

class SethStatePanic(State):
    
    def __init__(self, seth):
        
        State.__init__(self, "panic")
        self.seth = seth
        
    def check_conditions(self):
        
        #Have we paniced enough yet?        
        if self.seth.panic < 1000:
            self.seth.panic += 25
        else:
            return "running"            
        return None
        
        
    def entry_actions(self):
        
        self.seth.speed = 0.
        
class SethStateRunning(State):
    
    def __init__(self, seth):
        
        State.__init__(self, "running")
        self.seth = seth
        
        
    def check_conditions(self):
        
        #Have we eaten our fill?        
        #if self.seth.world.sri == True:
        #    pass
        #else:
        #    return "exploring"            
        return None
        
        
    def entry_actions(self):
        
        self.seth.speed = 200.
        w, h = global_data.WORLD_SIZE
        if randint(1, 2) == 1:
            self.seth.destination = Vector2(w+50, randint(0, h))
        else:
            self.seth.destination = Vector2(w-2048, randint(0, h))        
        #random_offset = Vector2(randint(-20, 20), randint(-20, 20))
        #self.ant.destination = Vector2(*self.ant.base_location) # + random_offset   
        
        
        
class Sri(GameEntity):
    
    def __init__(self, world, image):
        GameEntity.__init__(self, world, "sri", image)
        self.font = pygame.font.SysFont("arial", 24);
        self.state = "Moving"
        self.time = 0
        self.speed = 50. + randint(-20, 20)
        self.color = (128,128,128)
        self.location = (512, -50)
        self.destination = Vector2(512, 128)

        
    def render(self, surface):
        
        GameEntity.render(self, surface)
        
        if self.state == "Yell":     
            x, y = self.location
            label = self.font.render("Seth!", True, (0, 0, 0))
            surface.blit(label, (x-30, y-50))
        if self.state == "Bloody":
            x, y = self.location
            label = self.font.render("Bloody Hell!", True, (0, 0, 0))
            surface.blit(label, (x-60, y-50))
        
    def process(self, time_passed):
        
        x, y = self.location
        if x > global_data.WORLD_SIZE[0] + 2:
            self.world.remove_entity(self)
            return
        if y == 128:
            if self.time == 0:
                self.state = "Wait to Yell"
            self.time += 25
            if self.time == 1000:
                self.state = "Yell"
                self.world.add_sri()
            if self.time == 5000:
                self.state= "Bloody"
            if self.time == 8000:
                self.destination = Vector2(512, -2048)
            
        GameEntity.process(self, time_passed)
        
        

        class Seth(GameEntity):
    
    def __init__(self, world, image):
        GameEntity.__init__(self, world, "seth", image)
        self.dead_image = pygame.transform.flip(image, 0, 1)
        self.health = 100
        self.speed = 50. + randint(-20, 20)
        self.hungry = 1000
        self.panic = 0
        self.font = pygame.font.SysFont("arial", 16);
        
        exploring_state = statemachines.SethStateExploring(self)
        seeking_state = statemachines.SethStateSeeking(self)
        eating_state = statemachines.SethStateEating(self)
        panic_state = statemachines.SethStatePanic(self)
        running_state = statemachines.SethStateRunning(self)
        
        self.brain.add_state(exploring_state)
        self.brain.add_state(seeking_state)
        self.brain.add_state(eating_state)
        self.brain.add_state(panic_state)
        self.brain.add_state(running_state)
        
        self.color = (230, 230, 230)
        
        
    def bitten(self):
        
        self.health -= 1
        if self.health <= 0:
            self.speed = 0.
            self.image = self.dead_image
        self.speed = 140.
        
    def render(self, surface):
        
        GameEntity.render(self, surface)
        
        if self.hungry < 1000 and self.panic == 0:
            x, y = self.location
            label = self.font.render("YUM!", True, (0, 0, 0))
            surface.blit(label, (x, y+20))
            
        if self.panic > 0 and self.panic < 1000:
            x, y = self.location
            label = self.font.render("OH NO!", True, (0, 0, 0))
            surface.blit(label, (x-30, y-35))
            
        if self.panic == 1000:
            x, y = self.location
            label = self.font.render("RUN!", True, (0, 0, 0))
            surface.blit(label, (x-20, y-40))
                    
        #x, y = self.location
        #w, h = self.image.get_size()
        #bar_x = x - 12
        #bar_y = y + h/2
        #surface.fill( (255, 0, 0), (bar_x, bar_y, 25, 4))
        #surface.fill( (0, 255, 0), (bar_x, bar_y, self.health, 4))
        
    def process(self, time_passed):
        
        x, y = self.location
        if x > global_data.WORLD_SIZE[0] + 2:
            self.world.remove_entity(self)
            return
        
        GameEntity.process(self, time_passed)
        
        
class Spider(GameEntity):
    
    def __init__(self, world, image):
        GameEntity.__init__(self, world, "spider", image)
        self.dead_image = pygame.transform.flip(image, 0, 1)
        self.health = 25
        self.speed = 50. + randint(-20, 20)
        self.color = (128,128,128)
        
    def bitten(self):
        
        self.health -= 1
        if self.health <= 0:
            self.speed = 0.
            self.image = self.dead_image
        self.speed = 140.
        
    def render(self, surface):
        
        GameEntity.render(self, surface)
                
        x, y = self.location
        w, h = self.image.get_size()
        bar_x = x - 12
        bar_y = y + h/2
        surface.fill( (255, 0, 0), (bar_x, bar_y, 25, 4))
        surface.fill( (0, 255, 0), (bar_x, bar_y, self.health, 4))
        
    def process(self, time_passed):
        
        x, y = self.location
        if x > global_data.WORLD_SIZE[0] + 2:
            self.world.remove_entity(self)
            return
        
        GameEntity.process(self, time_passed)
        
        
        
        