Design for viewport user input management.



Surfaces

Viewports are layered onto the screen.  The lowest level has level 0 and then
continues from there, going up and modifiable directly by the developer.

A list is maintained by class functions.  When a viewport is added, the list is
sorted in ascending order.  When the layer value is modified, the list is also
sorted.

When rendering to the screen, the list is iterated through in sequence, rendering
first layer 0 and continues in ascending order.


User input.
Viewports are used to determine which window user input belongs to.

Attributes of the object related to user input (can be useful to the graphics
element of viewports also:)

#User defined layer number
self._layer = layer

self.is_visable=is_visable
If the image isn't visable, it is not eligible for user input.

self.rect = (self.x_right, self.y_down, self.width, self.height)
Stores the rect of the viewport.

self.exclusive = False
Defines if any user input can be passed onto the next layer.

self.mouse_events = False
Defines if there are any mouse events defined for this layer.  Value doesn't
matter if exclusive is set to true.

self.keyboard_events = False
Defines if there are any keybpard events defined for this layer.  Value doesn't
matter if exclusive is set to true.

Methods related to user input

Algorithm for user input direction to viewports.

Input to class method:
	the_event
	top_layer	#Layer to start on, default will start on the top most if no
				 value is provided.
				 
	for i in reversed viewports:
		if i._layer <= top_layer:
			if is_viewable:
			 	
            #  1.  Is it =< than the top_layer value
            #  2.  is_viewable  -  Is it an active window?
            #  3.  is_exclusive -  Can input only go to this window regardless
            #      mouse position?
            #  4.  is the mouse over this viewport
            #  5.
           
            
            
Multiprocess model.

Process 1



Design for stategic zoom version 2.

Requirements:
a.  Efficient memory and processing usage.
b.  Screen aspect ratio maintained in all zoom levels.  (Will need to add code to minimap.)

1.  Determine a maximum zoom in and zoom out.

Given size screen:

1200x800

Normal zoom is 1200x800

Any zoom in to this size could easily be the normal rendering of the screen and then and a cut with resize.

Should it be a smooth zoom, able to be at any given some level or should there be a predetermined number of zoom levels?


There must be a cutoff zoom level that goes from actual images to squares representing the entities.

To determine the zoom level cutover, calculate the smallest you want an image to be represented as.
For example, if the typical entity is 50x50, perhaps 10x10 is the smallest you want to go.  Then that is the
cutoff before the zoom level changes.

Create an asset cache that has all the entities prescaled.

Calculate the number of zoom levels based on the screen size vs. world size.

Examples:

world size = 5000x5000
screen size = 1000,1000
then number of zoom levels = 5

world size = 10,000 by 10,000
screen size = 1000x1000
the number of zoom levels = 10?

Zoom level change for every 50 percent growth?

world size is 10000x10000
screen size is 100x100
zoom level 3 would cover world size 150x150
zoom level 4 would cover world size 225x225
etc.

